/*
Three.js Roller Scene React component
------------------------------------
Files included below are all in this single textdoc. Copy into your React app (create-react-app or Vite).

Quick steps:
1) npm install three
2) Put the reference image in either:
   - public/images/roller.jpg  (recommended when using CRA/Vite public folder)
   - OR src/assets/roller.jpg and update the import path accordingly
3) Copy the component file below to src/components/RollerScene.jsx
4) Replace your src/App.jsx with the provided App.jsx (or import RollerScene into your existing App)
5) npm start

This component builds a scene of multiple textured cylinders (rollers), uses OrbitControls
for interaction, and animates the rotation of rollers to mimic conveyor rollers. It is
implemented using plain Three.js inside React (no react-three-fiber) so it's easy to drop in.
*/

// ------------------- src/components/RollerScene.jsx -------------------
import React, { useEffect, useRef } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

// If you placed the image in src/assets, uncomment the import below and comment out textureLoader.load() path.
// import rollerImg from "../assets/roller.jpg";

export default function RollerScene({ imagePath = "/images/roller.jpg" }) {
  const mountRef = useRef(null);

  useEffect(() => {
    const mount = mountRef.current;
    const width = mount.clientWidth;
    const height = mount.clientHeight;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    renderer.outputEncoding = THREE.sRGBEncoding;
    mount.appendChild(renderer.domElement);

    // Scene + Camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f4f8);

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 30, 60);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(10, 20, 10);
    dir.castShadow = true;
    scene.add(dir);

    // Ground plane (subtle)
    const planeGeo = new THREE.PlaneGeometry(400, 400);
    const planeMat = new THREE.MeshStandardMaterial({ color: 0xefefef });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -6;
    scene.add(plane);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 10;
    controls.maxDistance = 200;

    // Load texture
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load(imagePath, (tex) => {
      // configure repeating so pattern looks good on curved surface
      tex.wrapS = THREE.RepeatWrapping;
      tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(2, 1);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    });

    // Optionally create a simple normal map from the texture's luminance using a canvas
    // This creates subtle depth on the roller surface.
    function createNormalMapFromImage(img) {
      try {
        const canvas = document.createElement("canvas");
        canvas.width = img.image ? img.image.width : 512;
        canvas.height = img.image ? img.image.height : 512;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img.image || img, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const normal = ctx.createImageData(canvas.width, canvas.height);
        const ndata = normal.data;
        // very simple sobel-like edge to fake a normal
        for (let y = 1; y < canvas.height - 1; y++) {
          for (let x = 1; x < canvas.width - 1; x++) {
            const i = (y * canvas.width + x) * 4;
            const gx =
              (data[i + 4] - data[i - 4]) +
              (data[i + 4 + canvas.width * 4] - data[i - 4 + canvas.width * 4]);
            const gy =
              (data[i + canvas.width * 4] - data[i - canvas.width * 4]) +
              (data[i + canvas.width * 4 + 4] - data[i - canvas.width * 4 + 4]);
            // pack into normal map channels
            const nx = (gx / 255 + 1) * 0.5 * 255;
            const ny = (gy / 255 + 1) * 0.5 * 255;
            ndata[i] = nx;
            ndata[i + 1] = ny;
            ndata[i + 2] = 255;
            ndata[i + 3] = 255;
          }
        }
        ctx.putImageData(normal, 0, 0);
        const normalTex = new THREE.Texture(canvas);
        normalTex.needsUpdate = true;
        return normalTex;
      } catch (e) {
        return null;
      }
    }

    // Once texture is loaded, build rollers
    const rollersGroup = new THREE.Group();
    scene.add(rollersGroup);

    texture.onUpdate = () => {
      const normalMap = createNormalMapFromImage(texture);

      // Roller parameters
      const rollerCount = 6; // number of rollers
      const rollerRadius = 6;
      const rollerLength = 24;
      const gap = 12; // distance between centers along Z axis

      for (let i = 0; i < rollerCount; i++) {
        const cylGeo = new THREE.CylinderGeometry(rollerRadius, rollerRadius, rollerLength, 64, 1, true);
        // Rotate so axis points along X (default cylinder is Y axis)
        cylGeo.rotateZ(Math.PI / 2);

        // material
        const matProps = {
          map: texture,
          metalness: 0.2,
          roughness: 0.6,
          side: THREE.FrontSide,
        };
        if (normalMap) matProps.normalMap = normalMap;

        const mat = new THREE.MeshStandardMaterial(matProps);
        // Create roller mesh
        const roller = new THREE.Mesh(cylGeo, mat);
        roller.position.set(0, 0, (i - (rollerCount - 1) / 2) * gap);
        roller.castShadow = true;
        roller.receiveShadow = true;

        // Add small shafts (metal caps) at ends
        const shaftGeo = new THREE.CylinderGeometry(rollerRadius * 0.28, rollerRadius * 0.28, rollerLength + 2, 24);
        shaftGeo.rotateZ(Math.PI / 2);
        const shaftMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.9, roughness: 0.25 });
        const shaft = new THREE.Mesh(shaftGeo, shaftMat);
        shaft.position.copy(roller.position);
        shaft.position.y -= rollerRadius + 1.2; // slightly below main roller to look like support

        // small end caps
        const capGeo = new THREE.CylinderGeometry(0.9, 0.9, 2, 16);
        capGeo.rotateZ(Math.PI / 2);
        const capMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 1, roughness: 0.2 });
        const capLeft = new THREE.Mesh(capGeo, capMat);
        capLeft.position.set(-rollerLength / 2 - 1, roller.position.y, roller.position.z);
        const capRight = capLeft.clone();
        capRight.position.set(rollerLength / 2 + 1, roller.position.y, roller.position.z);

        rollersGroup.add(roller);
        rollersGroup.add(shaft);
        rollersGroup.add(capLeft);
        rollersGroup.add(capRight);
      }
    };

    // Animation
    const clock = new THREE.Clock();
    let req = null;
    const animate = () => {
      req = requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // rotate the rollers group a bit to simulate belt movement
      rollersGroup.children.forEach((child) => {
        if (child.type === "Mesh" && child.geometry.type === "CylinderGeometry") {
          // rotate around local X (because we rotated cylinder geometry)
          child.rotation.x += delta * 1.2; // adjust speed as needed
        }
      });

      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    // Handle resize
    const handleResize = () => {
      const w = mount.clientWidth;
      const h = mount.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", handleResize);

    // Clean up on unmount
    return () => {
      cancelAnimationFrame(req);
      window.removeEventListener("resize", handleResize);
      controls.dispose();
      renderer.dispose();
      mount.removeChild(renderer.domElement);
    };
  }, [imagePath]);

  return (
    <div style={{ width: "100%", height: "100%", minHeight: 500 }} ref={mountRef} />
  );
}

// ------------------- src/App.jsx -------------------
// Minimal App showing how to use the component

/*
// src/App.jsx
import React from 'react';
import RollerScene from './components/RollerScene';

function App() {
  // If you put the image in public/images/roller.jpg, you can just pass nothing and default will be used.
  // Or explicitly pass the path: <RollerScene imagePath={'/images/roller.jpg'} />
  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <RollerScene />
    </div>
  );
}

export default App;
*/

// ------------------- Notes & tips -------------------
/*
- Best place to store the image in a React app is public/images/roller.jpg. That way you can pass '/images/roller.jpg' to the component.
- If you want to import the image from src/assets: import rollerImg from '../assets/roller.jpg'; and pass imagePath={rollerImg}.
- Tweak rollerCount, rollerRadius, rollerLength, gap and texture.repeat to match the look in your reference image.
- For more realism, consider adding a subtle environment map, soft shadows (using a postprocessing solution), and AO maps.
- If you prefer react-three-fiber for easier declarative code, I can convert this to R3F â€” tell me and I'll convert.
*/